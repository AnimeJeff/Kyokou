# def answer(start, length):
#   checksum = None
#   i = 0
#   while length > 0:
#     sublength = length
#     print("length",length)
#     while sublength > 0:
#       print(sublength,start)
#     #   print()
#       if checksum:
#         checksum ^= start
#       else:
#         checksum = start
#       start += 1
#       sublength -= 1
#     length -= 1
#     start += i
#     i += 1
#   return checksum
# answer(17,4)

#https://github.com/ken-power/Foobar_Challenge/tree/main/Level_3/4_QueueToDo#solution
#https://codereview.stackexchange.com/questions/153262/calculate-xor-of-many-consecutive-and-non-consecutive-numbers/153274#153274

def solution(start, length):
    """
    A function that returns the same security checksum that the bunny trainers would have after they
    would have checked all the workers through. Fortunately, the workers' orderly nature causes them to always
    line up in numerical order without any gaps.

    :param start: a positive integer representing the ID of the first worker to be checked
    :param length: a positive integer representing the length of the line before the automatic review occurs
    :return: the same security checksum that the bunny trainers would have after they would have checked all
             the workers through
    """

    # All worker IDs (including the first worker) are between 0 and 2000000000 inclusive, and the checkpoint line
    # will always be at least 1 worker long.
    max_id = 2000000000
    range_boundary = start + length * length

    if range_boundary > max_id or start < 0 or length < 0:
        return None

    security_checksum = 0

    for security_id in range(0, length):  # treat each 'row' as a sequence of numbers
        first = start + (length * security_id)  # the first number in the row / sequence
        last = first + (length - security_id) - 1  # the last number in the row / sequence

        security_checksum ^= xor_of_sequence(first, last)  # update the checksum with the XOR for each row

    return security_checksum

def xor_of_sequence(first, last):
    """
    Get the XOR of a sequence of numbers. We can take advantage of the fact that the XOR operation repeats itself for
    sequential numbers.

    :param first: the first number in the sequence
    :param last: the last number in the sequence
    :return: the XOR of the sequence
    """
    if first % 2 == 0:  # if the first number in the sequence is even
        xor_pattern = [last, 1, last + 1, 0]
    else:  # if the first number in the sequence is odd
        xor_pattern = [first, first ^ last, first - 1, (first - 1) ^ last]

    return xor_pattern[(last - first) % 4]  # the XOR pattern repeats every 4 numbers

def visualProof():
    #consider 17 and 18 onwards
    start = 17
    start1 = start+1
    length = 16
    print(start,"\t\t\t\t",start1)
    for i in range(start+1,start+length+1):
        print(f"x^{i}=",start:=start^i,"\t\t\t",f"y^{i+1}=",start1:=start1^(i+1),)

    #if even first:
    #sequence is [last,1,last+1,0]

    #if odd first we compare the even sequence of the first+1
    #then sequence is [first,first^last,first-1,(first-1)^last]
    #third term because 18^19=1 and odd ^ 1 is equivalent to subtracting 1
    #fourth term because 17^(last+1), since last is even last+1 is odd so 17^last+1 is
    #equivalent to sutracting 1 from 17 and xor because xor is commutative doesnt matter if last two bits are 11 or 01


    print()
    print((20+1)^24)